////////////////////////////////////////////////////////////////////////////////////
// The sequence of triangle numbers is generated by adding the natural numbers. 
// So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. 
// The first ten terms would be:
//
// 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
//
// Let us list the factors of the first seven triangle numbers:
//
//  1: 1
//  3: 1,3
//  6: 1,2,3,6
// 10: 1,2,5,10
// 15: 1,3,5,15
// 21: 1,3,7,21
// 28: 1,2,4,7,14,28
// We can see that 28 is the first triangle number to have over five divisors.
// 
// What is the value of the first triangle number to have over five hundred divisors?
////////////////////////////////////////////////////////////////////////////////////
// euler_12.cpp
// By Salomao Becker
////////////////////////////////////////////////////////////////////////////////////
// Discussion: This problem involves a few different challenges, and this program's
// specifically written to deal with all these problems quickly and efficiently.
//
// The first problem is the generation of triangular numbers. How many do we need?
// Because we do not know, I've employed a pseudo-recursive way of picking the
// number I generate. I simply double the amount I generate on the next run, while
// maintaining the same structure the entire time I'm working with the entire time.
// This is way faster then allocating new memory on the vector every time I need to
// add a new element, and it's likely also faster than a linked list. Generating the
// actual triangular numbers is a simple recursion, again.
// 
// Problem number two is factoring. I've taken a choice that is a middle ground for
// easy to understand, and fast while numbers are still relatively small (we're not
// dealing with numbers large enough to be in security, for example). We will be
// factoring the number into its prime factors and then finding the combinations of
// those factors to get all the divisors.
//
// Using this method is fastest because I know that, due to the nature of needing 
// 500 divisors, I will not be needing really large prime numbers, I will need
// many small prime numbers (this is one of the major assumptions of the program,
// if this assumption proves to be false (it doesn't) the runtime of the program
// is expected to take an absolutely massive hit). Dividing this number by a few
// small primes a few times and applying a combinatorics formula is obviously faster
// then dividing a number by all numbers from 1 to n/2. 
//
// Problem three involves rapid prime generation. I employ a really fast method, the
// Sieve of Eratosthenes. See the function description for more details. A note is that,
// due to how the sieve works, I need to start from scratch every time. This mean that
// the classical "divide all the next number by all the previous primes" method might 
// wind up being faster because I do not have to regenerate the previous primes.
// With that being said, the sieve is definitely a lot faster when we make more primes.
// Since we do not generate a ton of primes, maybe the other method is trivially faster,
// but I like this one more. No big runtime hit.
//
// Problem four is the combinatorics formula. I figured it out on my own after a good deal
// of experimentation (I enjoy trying to figure out as much as I can by myself).
// For the number factored into the products of primes to a power, written generally as
// (a^b)(c^d)...(y^z), the combinations are (b+1)(c+1)...(z+1)
//
// Put them all together and you get the answer rather quickly. If I define the max primes
// and the number of initial triangles with large enough numbers, the runtime is trivially
// small. Starting with the lowest logical values, it takes about a second on my mid-end
// laptop.
////////////////////////////////////////////////////////////////////////////////////

#include <vector>
#include <math.h>
#include <iostream>
using namespace std;

////////////////////////////////////////////////////////////////////////////////////
// Generates a list of primes with maxPrimes elements
// Uses a sieveing method that utilizes an efficient bool array representing the numbers
// from 0 to twice the theoretical place where the maxPrimes-th prime should be (for safety)
////////////////////////////////////////////////////////////////////////////////////
vector<long long> generatePrimes(int maxPrimes)
{
	vector<long long> retval(maxPrimes);
	int index = 0;

	// This formula was looked up and algebra'd into this current form. It involves
	// a theorem that describes the probablity of a number being prime. It's something
	// I discovered in the past, that I use into today, when generating n number
	// of primes instead of primes up until n
	int top = 2*maxPrimes*log((double)maxPrimes);

	// Using the root is what's required in the seiving process. I square it back to
	// avoid any weirdness involving taking the square root of an integer.
	int root = sqrt((double)top) + 1;
	int square = root*root;

	// When you find a prime, declare any multiples of it as false. Using a bool array
	// where the position in the array represents the number, primes[7] will be true.
	vector<bool> primes(square, true);
	primes[0] = false; primes[1] = false;
	for(int i = 2; i < root; i++)
		if(primes[i])
			for(int j = 2*i; j < square; j+=i)
				primes[j] = false;

	for(int i = 2; i < square && index < maxPrimes; i++)
	{
		if(primes[i])
		{
			retval[index] = i;
			index++;
		}
	}

	return retval;
}

////////////////////////////////////////////////////////////////////////////////////
// Find the number of factors in a number in almost a constant speed. Because we don't
// need to factor large primes out of numbers (numbers with large primes won't yield
// the high number of divisors we need), we only need to factor up until the very small
// size of our primes array. Thus, we're factoring in near constant time.
////////////////////////////////////////////////////////////////////////////////////
int quickFactor(long long num, vector<long long>& primes)
{
	// The value of the unique primes doesn't matter, only the number of them, so
	// every time we get a new prime, we move into the next position of the array
	// and start counting anew
	vector<int> count(1);
	int result = 1;
	bool flag = true;
	for(int i = 0; num > 1 && i < primes.size(); i++)
	{
		// By dividing the num by the the value of the prime, we're able to extract
		// out the exact number of primes in each number.
		while(num%primes[i] == 0)
		{
			num/=primes[i];

			if(flag)
			{
				count.push_back(1);
				flag = false;
			}

			else
			{
				count[count.size() - 1]++;
			}
		}

		flag = true;
	}

	// Applies the combinatorics formula described in the dicussion
	for(int i = 0; i < count.size(); i++)
	{
		result *= (1 + count[i]);
	}

	return result;
}

////////////////////////////////////////////////////////////////////////////////////
// The psuedo-recursive version of our initial solve function. Check it for comments.
// The only difference is we keep track of the end of our array (so we don't generate
// triangles from the start) and that instead of making a triangle array, we just
// allocate space to the end.
////////////////////////////////////////////////////////////////////////////////////
long long solve2(vector<long long>& triangles, int maxPrimes)
{
	int initTriangleSpace = triangles.size();
	vector<long long> primes = generatePrimes(maxPrimes);
	triangles.resize(2*triangles.size());
	for(int i = initTriangleSpace; i < triangles.size(); i++)
	{
		triangles[i] = triangles[i-1] + i;
		if(quickFactor(triangles[i], primes) > 500)
		{
			return triangles[i];
		}
	}

		return solve2(triangles, maxPrimes + 5);
}

////////////////////////////////////////////////////////////////////////////////////
// I name all my big functions in the euler problems solve. This one puts everything
// together. It starts by generating a list of primes and allocating space for our 
// triangular numbers. It generates numbers as it goes, because it's not really
// important to generate numbers past what our answer is. If it finds the answer
// using quickFactor, it returns that number. Otherwise, it moves on to calculate
// and test the next triangle.
////////////////////////////////////////////////////////////////////////////////////
long long solve()
{
	int initTriangleSpace = 5; 
	int maxPrimes = 5;
	vector<long long> primes = generatePrimes(maxPrimes);
	vector<long long> triangles(initTriangleSpace);
	triangles[0] = 0;
	for(int i = 1; i < triangles.size(); i++)
	{
		triangles[i] = triangles[i-1] + i;
		if(quickFactor(triangles[i], primes) > 500)
		{
			return triangles[i];
		}
	}

	return solve2(triangles, maxPrimes + 5);
}

////////////////////////////////////////////////////////////////////////////////////
// I use the main function for output. cin at the end is to keep my output screen up
////////////////////////////////////////////////////////////////////////////////////
void main()
{
	cout << solve();
	while(cin);
}